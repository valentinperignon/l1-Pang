<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: script.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: script.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Jeu Pang (Avril 2019)
 * script.js
 * 
 * @author Fabian Devel, Nathanaël Houn, Valentin Perignon
 */

// -------------------------------------------------------------------------------
// ############################# Future JSON file ################################
// -------------------------------------------------------------------------------

/** 
 * Array of all the platforms.
 * With position (x and y), width, height, height, exist and detructibility
 */
const PLATFORMS_LIST = {
    level1 : [],
    level2 : [
        {
            "position":{
                "x": 575,
                "y": 200
            },
            "width": 120,
            "height": 400,
            "exist": true,
            "isDestructible": false
        },
        {
            "position":{
                "x": 460,
                "y": 200
            },
            "width": 80,
            "height": 40,
            "exist": true,
            "isDestructible": false
        },
        {
            "position":{
                "x": 275,
                "y": 200
            },
            "width": 80,
            "height": 40,
            "exist": true,
            "isDestructible": false
        },
        {
            "position":{
                "x": 125,
                "y": 400
            },
            "width": 80,
            "height": 40,
            "exist": true,
            "isDestructible": true
        }
    ],

    level3 : [
        {
            "position":{
                "x": 275,
                "y": 200
            },
            "width": 80,
            "height": 40,
            "exist": true,
            "isDestructible": false
        },
        {
            "position":{
                "x": 125,
                "y": 200
            },
            "width": 80,
            "height": 40,
            "exist": true,
            "isDestructible": true
        },
        {
            "position":{
                "x": 700,
                "y": 500
            },
            "width": 100,
            "height": 100,
            "exist": true,
            "isDestructible": true
        }
    ]
}

/** 
 * Array of all the ladders.
 * With position (x and y), width and height
 */
const LADDER_WIDTH = 90;
const LADDERS_LIST = {
    "level1": [],
    "level2": [
        {
            "position":{
                "x": 35,
                "y": 400
            },
            "width": LADDER_WIDTH,
            "height": 200,
        }
    ],
    "level3": [
        {
            "position":{
                "x": 35,
                "y": 400
            },
            "width": LADDER_WIDTH,
            "height": 200,
        },
        {
            "position":{
                "x": 600,
                "y": 400
            },
            "width": LADDER_WIDTH,
            "height": 200,
        }
    ]
};

/**
 * List of size of balloons
 */
const BALLOON_SIZE = [
    {number: 0,
    radius: 0,
    Yvelocity:0
    },
    {number: 1,
    radius: 15,
    Yvelocity: -6
    },
    {number: 2,
    radius: 30,
    Yvelocity: -7.1
    },
    {number: 3,
    radius: 40,
    Yvelocity: -8.4
    },
    {number: 4,
    radius: 50,
    Yvelocity: -9.5
    }
]

/** 
 * Array of all the balloons.
 * With center position (x and y), radius, velocity (x and y), and ballons gravity
 */
const BALLOONS_LIST = {
    "level1": [
        {
            center: {x: 400, y:30},
            size: BALLOON_SIZE[4],
            velocity:{ x: -1, y: 0},
            gravity: {x :0, y: 9.81/1000},
        }
    ],

    "level2": [
        {
            center: {x: 400, y:30},
            size: BALLOON_SIZE[4],
            velocity:{ x: -1, y: 0},
            gravity: {x :0, y: 9.81/1000},
        },
        {
            center: {x: 500, y:30},
            size: BALLOON_SIZE[4],
            velocity:{ x: 1, y: 0},
            gravity: {x :0, y: 9.81/1000},
        }
    ],

    "level3": [
        {
            center: {x: 400, y:30},
            size: BALLOON_SIZE[4],
            velocity:{ x: -1, y: 0},
            gravity: {x :0, y: 9.81/1000},
        },
        {
            center: {x: 500, y:30},
            size: BALLOON_SIZE[4],
            velocity:{ x: 1, y: 0},
            gravity: {x :0, y: 9.81/1000},
        },
        {
            center: {x: 600, y:30},
            size: BALLOON_SIZE[4],
            velocity:{ x: 1, y: 0},
            gravity: {x :0, y: 9.81/1000},
        }
    ]
}

// -------------------------------------------------------------------------------
// ################################ Variables ####################################
// -------------------------------------------------------------------------------

/** Context */
var context = null;

/** Level number */
var numLevel = 0;

/**
 * Variables about game state.
 * With focus, pause, victory and defeat
 */
var isOnFocus = true;
var pause = false;
var victory = false;
var defeat = false;
var isInvincible = false;                                                                                           // BETA isInvicible

/** Timer */
var timer = 100;

/** An array of all the balloons in the game
 * With the position, the radius, the velocity, gravity and the color
 */
var balloons = [];

/** Balloons related variables */
const BALLOON_SPEED = 0.1;

/** Date of the last update */
var lastUpdate = Date.now();

/** A player
 * With his position (x and y), speed (x and y), height, width, power on, shield, lives number and color */
var player = {position: {x: 0, y: 0}, speed: {x: 0, y: 0}, height: 0, width: 0, powerOn: 0, shieldOn: 0, score: 0, livesNumber: 3, color: "blue"};
const PLAYER_SPEED = 500;
const GRAVITY = {x: 0, y: 1500};
var isGravity = 0;

/** 
 * Array of weapons.
 * With type (0: is not active), position, length and shooting
 */
var weapons = [] ;

/** Weapons related variables */
    // - Hooks
const GRAPPLE_HOOK_NUMBER = 1 ;
const DOUBLE_HOOK_NUMBER = 2 ;
const TRIDENT_NUMBER = 3 ;
const HOOK_SPEED = 0.3 ;
const HOOK_WITDH = 5;
    // - Others weapons
// ADD HERE

/** All the platforms */
var platforms = [] ;

/** Ladders in the game */
var ladders = [] ;

/** Constants for the graphical part */
const DESTRUCTIBLE_PLATFORM_COLOR = "darkgrey";
const PLATFORM_COLOR = "black";
const LADDER_COLOR = "gray";
var BALLOON_COLOR;
var BALLON_GRADIENT;
const GRAPPLE_HOOK_COLOR = "red";
const TRIDENT_COLOR1 = "orangered";
const TRIDENT_COLOR2 = "orange";
const TRIDENT_COLOR3 = "yellow";

// ------------------------------------------------------------------------------------------------
// ######################################## Functions #############################################
// ------------------------------------------------------------------------------------------------

/**
* Level selection : initialize all the variables
*/
function levelInitialization(num){
    //JSON.parse(JSON.stringify(var)) is to make a copy of the object and not a copy of the adress.
    switch(num){
        case 2:
            ladders = JSON.parse(JSON.stringify(LADDERS_LIST.level2));
            platforms = JSON.parse(JSON.stringify(PLATFORMS_LIST.level2));
            balloons = JSON.parse(JSON.stringify(BALLOONS_LIST.level2));
            BALLOON_COLOR = "blue";
        break;

        case 3:
            ladders = JSON.parse(JSON.stringify(LADDERS_LIST.level3));
            platforms = JSON.parse(JSON.stringify(PLATFORMS_LIST.level3));
            balloons = JSON.parse(JSON.stringify(BALLOONS_LIST.level3));
            BALLOON_COLOR = "green";
        break;
            
        default:
            ladders = JSON.parse(JSON.stringify(LADDERS_LIST.level1));
            platforms = JSON.parse(JSON.stringify(PLATFORMS_LIST.level1));
            balloons = JSON.parse(JSON.stringify(BALLOONS_LIST.level1));
            BALLOON_COLOR = "red";
    }

    // initialization of the player
    player.height = 75;
    player.width = 70;
    player.position.x = context.width/2 - player.width/2;
    player.position.y = context.height - player.height;
    player.powerOn = GRAPPLE_HOOK_NUMBER;

    //Initialisation of the timer
    timer = 100;

    //No weapon
    weapons = [];
}

/**
 * Moving the player (horizontally)
 */
playerMove = function(move) {
    switch (move) {
        case 39:
            player.speed.x = PLAYER_SPEED;
            break;
        case 37:
            player.speed.x = -PLAYER_SPEED;
            break;
    }
}

/**
 * Stop the player's movement (horizontally)
 */
playerStopMove = function(move) {
    switch (move) {
        case 39:
            if(player.speed.x > 0) {
                player.speed.x = 0;
            }
            break;
        case 37:
            if(player.speed.x &lt; 0) {
                player.speed.x = 0;
            }
            break;
    }
}

/**
 * Moving the player (with ladders)
 */
playerMoveLadder = function(move) {
    if(findLadder() != -1) {
        switch(move) {
            case 38:
                player.speed.y = -PLAYER_SPEED;
                break;
            case 40:
                player.speed.y = PLAYER_SPEED;
                break;
        }
    }
}

/**
 * Stop the player's movement (with ladders)
 */
playerStopMoveLadder = function() {
    player.speed.y = 0;
}

/**
 * Return the ladder array's index
 */
findLadder = function() {
    var i=0;
    var find = false;

    while(i&lt;ladders.length &amp;&amp; !find) {
        if(player.position.x >= ladders[i].position.x - 0.33*player.width &amp;&amp; player.position.x &lt;= ladders[i].position.x + ladders[i].width - 0.66*player.width) {
            if(player.position.y >= ladders[i].position.y - 1.1*player.height &amp;&amp; player.position.y &lt;= context.height) {
                find = true;
            } else {
                i++;
            }
        } else {
            i++
        }
    }

    if(i == ladders.length) {
        i = -1;
    }
    return i;
}

/**
 * Detect if the player is on a platform
 */
detectPlatform = function() {
    var isOn = true;

    for(var i=0; i&lt;platforms.length; i++) {
        if(!platforms[i].exist
        || player.position.x + player.width &lt; platforms[i].position.x
        || player.position.x > platforms[i].position.x + platforms[i].width
        || player.position.y > platforms[i].position.y + platforms[i].height
        || player.position.y + player.height &lt; platforms[i].position.y) {
            isOn = false;
        } else {
            isOn = true;
        }
    }

    return isOn;
}

/**
 * Return true if the player is not on the ground, a platform, or a ladder
 */
function isNotOnPlatformOrGround(){
    isNot = false;

    if(player.position.y + player.height &lt; context.height &amp;&amp; findLadder() == -1 &amp;&amp; !detectPlatform()) { // not on the ground
        isNot = true;
    }

    return(isNot);
}

/**
 * It does exactly what you expect
 */
function keepPlayerWithinBorder() {
    if(player.position.x &lt; 0) {
        player.position.x = 0;
    } else {
        if(player.position.x > context.width-player.width) {
            player.position.x = context.width-player.width
        }
    }

    if(player.position.y &lt; 0) {
        player.position.y = 0;
    } else {
        if(player.position.y > context.height-player.height) {
            player.position.y = context.height-player.height
        }
    }
}

/**
 * Checks if the player will collide with an object
 * @param {*} ball - The player
 * @param {float} newPosX - The (maybe) new X coordinate of the player
 * @param {float} newPosY - The (maybe) new Y coordinate of the player
 * @param {*} object - A rectangular object
 * 
 * @returns {boolean} True if the player will collide with the object
 */
function isPlayerWithinObject(player,newPosX,newPosY,object){
    var correction = false;
    if(object.exist){
        //
        if(newPosX + player.width &lt; object.position.x || newPosX > object.position.x + object.width){
            //No problem
        } else {
            if(newPosY + player.height &lt;= object.position.y || newPosY >= object.position.y + object.height){
                // No problem
            } else {
                correction = true;
            }
        }
    }
    return(correction);
}

/**
 * Keep balloons inside of the canvas
 * @param {*} ball - A balloon
 *
 * @returns {int} The changement
 */
function keepBalloonWithinBorders(ball){
    var changement = false;
    //Top
    if(ball.center.y &lt; ball.size.radius){
        ball.center.y = ball.size.radius;
        ball.velocity.y = -ball.velocity.y;
        changement = true;
    } else {
        //Bottom
        if(ball.center.y > cvs.height - ball.size.radius){
            ball.center.y = cvs.height - ball.size.radius;
            ball.velocity.y = ball.size.Yvelocity;
            changement = true;
        }
    }
    //Left
    if(ball.center.x &lt; ball.size.radius){
        ball.center.x = ball.size.radius;
        ball.velocity.x = -ball.velocity.x;
        changement = true;
    } else {
        //Right
        if(ball.center.x > cvs.width-ball.size.radius){
            ball.center.x = cvs.width - ball.size.radius;
            ball.velocity.x = -ball.velocity.x;
            changement = true;
        }
    }
    return(changement);
}

/**
 * Update the gradient of a circle
 * @param {*} circle - Balloon which will be update
 */
updateCircleColor = function(circle) {
    BALLON_GRADIENT = context.createRadialGradient(circle.center.x-circle.size.radius/3, circle.center.y-circle.size.radius/3, circle.size.radius/5, circle.center.x, circle.center.y, circle.size.radius);

    switch(BALLOON_COLOR) {
        case "blue":            
            BALLON_GRADIENT.addColorStop(0, '#5e92f3');
            BALLON_GRADIENT.addColorStop(.2, '#1565c0');
            BALLON_GRADIENT.addColorStop(1, '#003c8f');
            break;
        case "red":
            BALLON_GRADIENT.addColorStop(0, '#ff7961');
            BALLON_GRADIENT.addColorStop(.2, '#f44336');
            BALLON_GRADIENT.addColorStop(1, '#ab000d');
            break;
        case "green":
            BALLON_GRADIENT.addColorStop(0, '#76d275');
            BALLON_GRADIENT.addColorStop(.2, '#43a047');
            BALLON_GRADIENT.addColorStop(1, '#00701a');
    }
}

/**
 * Draw a circle
 * @param {*} circle - Balloon which will be draw
 */
function fillCircle(circle){
    updateCircleColor(circle);

    context.beginPath();
    context.fillStyle=BALLON_GRADIENT;
    context.arc(circle.center.x, circle.center.y, circle.size.radius, 0, 2 * Math.PI);
    context.fill();
}


/**
 * Detect the victory (= no balloon remaining)
 */
function isVictory(){
    var isOneBalloonRemaining = false;
    var i=0
    while(i&lt;balloons.length &amp;&amp; !isOneBalloonRemaining){
        if(balloons[i].size.number > 0){
            isOneBalloonRemaining = true;
        }
        i++;
    }
    return(!isOneBalloonRemaining);
}

/**
 * Detect the defeat 
 * (i.e. if there is no time and no ballon remaining)
 * returns {boolean} true if the defeat is real
 */
isDefeat = function(ball) {
    var defeat = false;

    // check
    if(timer &lt;= 1 &amp;&amp; !isVictory()) {
        defeat = true;
    } else if(ball.size.number > 0 &amp;&amp; collisionsWithPlayer(ball, player) &amp;&amp; !isInvincible){                                             // BETA IsInvicible
        defeat = true;    
    }
    return defeat;
}



// #####################################
// #### Shoot, manage and delete Weapons

/**
*
*/
function isWeaponBetweenX(weapon,rectangle){
    return(!(weapon.position.x + HOOK_WITDH &lt; rectangle.position.x || weapon.position.x > rectangle.position.x + rectangle.width));
}

/**
* Fire a weapon
*/
function shootWeapon(player){
    switch(player.powerOn){
        case GRAPPLE_HOOK_NUMBER:
            shootGrappleHook();
            break;

        case DOUBLE_HOOK_NUMBER:
            shootGrappleHook();
            break;

        case TRIDENT_NUMBER:
            shootGrappleHook();
            break;
    }
}

/**
 * Shoot a hook
 */
function shootGrappleHook(){
    //No actual grapple hook shooted or double grapple hook bonus is on
    if(weapons.length==0 
    || (weapons.length &lt; 2 &amp;&amp; player.powerOn == DOUBLE_HOOK_NUMBER)){
        weapons[weapons.length] = {
            type: player.powerOn,
            shooting: true,
            position: {x: player.position.x+player.width/2 , y: player.position.y+player.height}, 
            length: 0,
            time: 0    
        };
    }
}

/**
 * Delete the drawing of the weapon
 */
function deleteWeapon(){
    weapons = [];
}

/**
 * Delete a double hook that is on the top
 */
function deleteDoubleHook(){
    var temp = weapons.filter(weapons => weapons.shooting);
    weapons = temp;
}


/**
 * Checking if the hook should stop
 */
function stopHooks(hook){
    // Hit the top of the screen
    if(hook.position.y - hook.length &lt; 0){
        switch(hook.type){
            case GRAPPLE_HOOK_NUMBER :
                deleteWeapon();
            break;

            case DOUBLE_HOOK_NUMBER:
                hook.shooting = false;
                deleteDoubleHook();
            break;                    

            case TRIDENT_NUMBER :
                hook.shooting = false;
                if(hook.time > 3){
                    deleteWeapon();
                }
            break;

            
        }
    } else {

        //Hit a platform
        var isItHittingPlatform = false;

        for(var i=0 ; i&lt;platforms.length ; i++){
            if(platforms[i].exist &amp;&amp; isWeaponBetweenX(hook,platforms[i])){
                if(hook.position.y - hook.length  &lt; platforms[i].position.y + platforms[i].height &amp;&amp; hook.position.y > platforms[i].position.y){
                    
                    switch(hook.type){
                        case GRAPPLE_HOOK_NUMBER :
                            deleteWeapon();
                            if(platforms[i].isDestructible){
                                platforms[i].exist = false;
                            }
                            break;
                        
                        case DOUBLE_HOOK_NUMBER :
                            hook.shooting = false;
                            deleteDoubleHook();
                            if(platforms[i].isDestructible){
                                platforms[i].exist = false;
                            }
                            break;

                        case TRIDENT_NUMBER :
                            hook.shooting = false;
                            if(hook.time > 3){
                                deleteWeapon();
                            }
                            break;
                    }
                }
            }
        }
    }

    //Hitting a balloon
    for(var i=0 ; i&lt;balloons.length ; i++){
        if(balloons[i].size.number > 0){

            if( Math.pow(balloons[i].center.x - hook.position.x, 2) &lt; Math.pow(balloons[i].size.radius, 2) 
            &amp;&amp; balloons[i].center.y + balloons[i].size.radius > hook.position.y - hook.length){

                switch(hook.type){
                    case GRAPPLE_HOOK_NUMBER:
                    case TRIDENT_NUMBER:
                        deleteWeapon(hook);
                    break;

                    case DOUBLE_HOOK_NUMBER:
                        hook.shooting = false;
                        deleteDoubleHook();
                    break;
                }         

                //Points
                player.score += balloons[i].size.radius*10 ;
                
                //Two new balloons if the balloons is not of the minimal size
                if(balloons[i].size.number > 1){
                    var oldBall = balloons[i];

                    balloons[balloons.length] =  {
                        center: {x: oldBall.center.x, y: oldBall.center.y},
                        size: BALLOON_SIZE[oldBall.size.number - 1],
                        velocity:{ x: -1, y: -2},
                        gravity: {x :0, y: 9.81/1000}
                    };
                    
                
                    balloons[balloons.length] =  {
                        center: {x: oldBall.center.x, y: oldBall.center.y},
                        size: BALLOON_SIZE[oldBall.size.number - 1],
                        velocity:{ x: 1, y: -2},
                        gravity: {x :0, y: 9.81/1000}
                    };
                }
                

                //Delete the balloon
                balloons[i].size = BALLOON_SIZE[0];
            }
        }
    }

}


// ######################################
// #### Balloons and platforms collisions

/**
*
*/
function squareDistanceBetweenPoints(pointA,pointB){
    return((pointA.x - pointB.x)*(pointA.x - pointB.x) + (pointA.y - pointB.y)*(pointA.y - pointB.y));
}


/**
* Is the balloonX between the x and (x + width) of the rectangle ? Return boolean
* Inputs : balloon with x, rectangle with x and width
*/
function isBalloonBetweenRectangleX(ball,rectangle){
    return(ball.center.x > rectangle.position.x &amp;&amp; ball.center.x &lt; rectangle.position.x + rectangle.width);
}

/**
* Is the ballon Y between the y and (y + width) of the rectangle ? Return boolean
* Inputs : balloon with y, rectangle with y and height
*/
function isBalloonBetweenRectangleY(ball,rectangle){
    return(ball.center.y >= rectangle.position.y &amp;&amp; ball.center.y &lt;= rectangle.position.y + rectangle.height);
}

/**
* Is the balloon near a plateform ? (= near to collide but we don't know if it does)
* @return true or false
*/
function isBalloonNearObject(ball,object){
    return(!(ball.center.x &lt; object.position.x - ball.size.radius
    || ball.center.x > object.position.x + object.width + ball.size.radius
    || ball.center.y &lt; object.position.y - ball.size.radius
    || ball.center.y > object.position.y + object.height + ball.size.radius))
}

/**
* @return 'true' if the balloon touches the bottom or the upside of a rectangular object
*/
function isInHorizontalCollision(ball, object){
    var collision = false;
    if(isBalloonBetweenRectangleX(ball, object)){
        if(ball.center.y >= object.position.y - ball.size.radius 
        &amp;&amp; ball.center.y &lt;= object.position.y + object.height + ball.size.radius){
            collision = true;
        }
    }
    return(collision);
}

/**
*@return 'true' if the balloon touches the left or the right of a rectangular object
*/
function isInVerticalCollision(ball, object){
    var collision = false;
    if(isBalloonBetweenRectangleY(ball, object)){
        if(ball.center.x >= object.position.x - ball.size.radius
        &amp;&amp; ball.center.x &lt;= object.position.x + object.width + ball.size.radius){
            collision = true;
        }
    }
    return(collision);
}



/**
* Is the balloon colliding with the bottom right corner ?
* @return true is yes, else false
*/
function isBalloonCollidingBottomRightCorner(ball,object){
    let bottomRightCorner = {x: object.position.x + object.width, y: object.position.y + object.height} ;
    return(squareDistanceBetweenPoints(ball.center,bottomRightCorner) &lt;= ball.size.radius * ball.size.radius);
}

/**
* Is the balloon colliding with the top right corner ?
* @return true is yes, else false
*/
function isBalloonCollidingTopRightCorner(ball,object){
    let topRightCorner = {x: object.position.x + object.width, y: object.position.y} ;
    return(squareDistanceBetweenPoints(ball.center,topRightCorner) &lt;= ball.size.radius * ball.size.radius);
}

/**
* Is the balloon colliding with the top left corner ?
* @return true is yes, else false
*/
function isBalloonCollidingTopLeftCorner(ball,object){
    let topLeftCorner = {x: object.position.x, y: object.position.y} ;
    return(squareDistanceBetweenPoints(ball.center,topLeftCorner) &lt;= ball.size.radius * ball.size.radius);
}

/**
* Is the balloon colliding with the top right corner ?
* @return true is yes, else false
*/
function isBalloonCollidingBottomLeftCorner(ball,object){
    let bottomLeftCorner = {x: object.position.x, y: object.position.y + object.height} ;
    return(squareDistanceBetweenPoints(ball.center,bottomLeftCorner) &lt;= ball.size.radius * ball.size.radius);
}

/**
 * Make sure the balloons are not colliding with rectangle objects like platforms
 * @param {*} ball - The balloon
 * @param {*} object - A rectangular object
 * 
 * @returns {boolean} True if the balloon collided with the object
 */
function keepBalloonOutsideObjects(ball, object){
    if(object.exist){
        var correction = false;

        // Is the balloon near the object ? Simple and quick verification (optimize)
        if(isBalloonNearObject(ball,object)){
            
            // Collision with horizontal surfaces
            if(isInHorizontalCollision(ball,object)){
                ball.velocity.y *= -1;
                correction = true;

            // or collision with vertical surfaces
            } else if(isInVerticalCollision(ball,object)){
                ball.velocity.x *= -1;
                correction = true;

            // or in collision with angles
            } else {
                
                //Top left corner
                if(isBalloonCollidingTopLeftCorner(ball,object)){
                    correction = true;
                    // Equation of the angle straith line (@return y)
                    function equation(x){
                        return(-(x-object.position.x) + object.position.y);
                    }

                    // The balloon is in the vertical area
                    if(ball.center.y > equation(ball.center.x)){
                        ball.velocity.x *= -1;

                    // The balloon is in the horizontal area
                    } else {
                        ball.velocity.y *= -1;
                    }


                //Top right corner
                } else if(isBalloonCollidingTopRightCorner(ball,object)){
                    correction = true;
                    // Equation of the angle straith line (@return y)
                    function equation(x){
                        return((x-object.position.x-object.width) + object.position.y);
                    }

                    // The balloon is in the vertical area
                    if(ball.center.y > equation(ball.center.x)){
                        ball.velocity.x *= -1;

                    // The balloon is in the horizontal area
                    } else {
                        ball.velocity.y *= -1;
                    }

                // Bottom left corner
                } else if(isBalloonCollidingBottomLeftCorner(ball,object)){
                    correction = true;
                    // Equation of the angle straith line (@return y)
                    function equation(x){
                        return((x-object.position.x) + object.position.y + object.height);
                    }

                    // The balloon is in the vertical area
                    if(ball.center.y &lt; equation(ball.center.x)){
                        ball.velocity.x *= -1;

                    // The balloon is in the horizontal area
                    } else {
                        ball.velocity.y *= -1;
                    }

                // Bottom right corner
                } else if(isBalloonCollidingBottomRightCorner(ball,object)){
                    correction = true;
                    // Equation of the angle straith line (@return y)
                    function equation(x){
                        return((x - object.position.x - object.width ) + object.position.y + object.height);
                    }

                    // The balloon is in the vertical area
                    if(ball.center.y &lt; equation(ball.center.x)){
                        ball.velocity.x *= -1;

                    // The balloon is in the horizontal area
                    } else {
                        ball.velocity.y *= -1;
                    }
                }
            }
        }
    }
    return(correction);
}

/**
* Collision with any angles with the others functions
*/ 
function collisionsAngles(ball,object){
    return(isBalloonCollidingBottomLeftCorner(ball,object)
    || isBalloonCollidingBottomRightCorner(ball,object)
    || isBalloonCollidingTopLeftCorner(ball,object)
    || isBalloonCollidingTopRightCorner(ball,object));
}

/**
* Call the other testing functions and return if there's a collision
*/
function collisionsWithPlayer(ball, object){
    var collisionAngles = collisionsAngles(ball, object).collision;
    var collisionY = isInVerticalCollision(ball, object);
    var collisionX = isInHorizontalCollision(ball, object);
    return(collisionAngles || collisionX || collisionY);
}

/**
*
*/
function outputSpeed(ball){
    var speed = Math.sqrt(Math.pow(ball.velocity.x, 2) + Math.pow(ball.velocity.y, 2));
    console.log(speed);
}

// ------------------------------------------------------------------------------------------------
// ########################################## Game  ###############################################
// ------------------------------------------------------------------------------------------------

/**
* Initialization of the game
*/
init = function() {
    // Initizalisation of the global var context
    context = document.getElementById("cvs").getContext("2d");
    context.width = document.getElementById("cvs").width;
    context.height = document.getElementById("cvs").height;

    // initialization with level
    levelInitialization(1);

    //Pause if it is not on focus
    document.body.onblur = function() {
        isOnFocus = false;
    }
    document.body.onfocus = function() {
        isOnFocus = true;
    }


    // 2 listeners on the keyboard (keyup and keydown)
    document.addEventListener("keydown", captureKeyboardPress)
    document.addEventListener("keyup", captureKeyboardReleased)

    

    // Go my little game loop, and never stop
    gameLoop();
}

/**
* Game loop
*/
gameLoop = function() {
    var delta = Date.now()-lastUpdate;
    lastUpdate = Date.now();
    // Run the game if it is not on pause
    if(!isOnFocus || pause){
        document.title = "Pang - en pause";
    } else {
        if(victory || defeat) {
            if(victory) {
                document.title = "Pang - gagné !";
            } else {
                document.title = "Pang - perdu...";
            }
            // draw the game
            render();
        } else {
            document.title = "Pang";

            // update of the game's state
            update(delta);
            // draw the game
            render();
        }
    }

    requestAnimationFrame(gameLoop);
}

/**
*  Game update
*  @param delta the time between now and the last update
*/
update = function(delta) {
    // update timer
    timer -= delta/1000;

    // Update balloons position 
    for(var i=0 ; i&lt;balloons.length ; i++){
        if(balloons[i].size.number > 0){
            // Update balloons[i].velocity
            balloons[i].velocity.x += balloons[i].gravity.x*delta;
            balloons[i].velocity.y += balloons[i].gravity.y*delta;

            // Update balloons[i].center
            balloons[i].center.x += balloons[i].velocity.x * delta * BALLOON_SPEED;
            balloons[i].center.y += balloons[i].velocity.y * delta * BALLOON_SPEED;
        }
    }

    //Verifying that balloons do not crash into something
    for(var i=0 ; i &lt; balloons.length ; i++){

        if(balloons[i].size.number > 0){    
            //No, you will not stick out
            var bordersCorrection = keepBalloonWithinBorders(balloons[i]);
            if(!bordersCorrection){    
                //Don't go into platforms !
                var correction = false;
                var j=0 ;
                while(j &lt; platforms.length &amp;&amp; !correction){
                    correction = keepBalloonOutsideObjects(balloons[i], platforms[j]);
                    j++;
                }
            }
        }
    }

    // Weapons will deal a lot of damages
    for(var i=0 ; i&lt;weapons.length ; i++){

        // Weapon is going up
        if(weapons[i].shooting==true){

            switch(weapons[i].type){

                case GRAPPLE_HOOK_NUMBER:
                case DOUBLE_HOOK_NUMBER:
                case TRIDENT_NUMBER:
                    weapons[i].length += HOOK_SPEED * delta ;
                break;
            }
        } else {

            //Increase the timer of the trident
            if(weapons[i].type == TRIDENT_NUMBER){
                weapons[i].time += delta/1000;
            }
        }

        stopHooks(weapons[i]);
    }

    // New player's position
    var newPosXPlayer = player.position.x + player.speed.x*delta/1000, newPosYPlayer = player.position.y + player.speed.y*delta/1000
    var newSpdXPlayer = player.speed.x + isGravity*GRAVITY.x*delta/1000, newSpdYPlayer = player.speed.y + isGravity*GRAVITY.y*delta/1000;
    if(findLadder() != -1) {
        if(newPosYPlayer + player.height &lt; ladders[findLadder()].position.y) {
            newPosYPlayer = ladders[findLadder()].position.y - player.height;
        }
    } else {
        if(newPosYPlayer &lt; player.position.y) {
            newPosYPlayer = player.position.y;
        }
    }
    if(isNotOnPlatformOrGround()) {
        isGravity = 1;
    } else {
        isGravity = 0;
    }

    var willCollide = false;
    var obstacleNumber = -1;
    for(var i=0 ; i&lt;platforms.length ; i++){
        if(isPlayerWithinObject(player,newPosXPlayer,newPosYPlayer,platforms[i])){
            willCollide = true;
            obstacleNumber = i;
        }
    }

    if(willCollide){
        //Vertical
        if(newSpdYPlayer &lt; 0 &amp;&amp; platforms[obstacleNumber].position.y + platforms[obstacleNumber].height &lt;= player.position.y){
            newPosYPlayer = platforms[obstacleNumber].position.y + platforms[obstacleNumber].height;
            newSpdYPlayer = 0
        }  else {
            //Horizontal
            if(newSpdXPlayer>0){
                newPosXPlayer = platforms[obstacleNumber].position.x - player.width;    
            } else if(newSpdXPlayer&lt;0){
                newPosXPlayer = platforms[obstacleNumber].position.x + platforms[obstacleNumber].width;
            }
            newSpdXPlayer = player.speed.x;
        }
    }

    // Update player
    player.position.x = newPosXPlayer;
    player.position.y = newPosYPlayer;
    player.speed.x = newSpdXPlayer;
    player.speed.y = newSpdYPlayer;
    keepPlayerWithinBorder();


    //Detect the victory
    if(isVictory()){
        victory = true;
    }
    //Detect the defeat
    for(var i=0 ; i&lt;balloons.length ; i++){
        if(isDefeat(balloons[i])){
            defeat = true;
        }
    }
}

/**
*  Game render
*/
render = function() {
    if(numLevel == 0) { 
        // ---------------
        // MENU
        // ---------------

        // variables d'affichage
        var textCopyright = "© Fabian D., Nathanaël H., Valentin P.";
        var textPlay = "ENTRÉE POUR COMMENCER ...";
        var textLevel = "OU SAISISSEZ LE NIVEAU";

        // fond noir
        context.fillStyle = "black";
        context.fillRect(0, 0, context.width, context.height);

        // affichage du logo Pang
        context.drawImage(logo, (context.width-400)/2, 80, 400, 189);

        // affichage du texte "copyright"
        context.fillStyle = "white";
        context.font = "17px Georgia";
        context.fillText(textCopyright, (context.width - context.measureText(textCopyright).width)/2, 189+80+20);

        // affichage du texte "Commencer à jouer..."
        context.fillStyle = "white";
        context.font = "35px Georgia";
        context.fillText(textPlay, (context.width - context.measureText(textPlay).width)/2, context.height-110-50);
        context.font = "25px Georgia";
        context.fillText(textLevel, (context.width - context.measureText(textLevel).width)/2, context.height-70-50);
    } else {
        // ---------------
        // GAME
        // ---------------

        // Wiping the screen
        context.clearRect(0, 0, context.width, context.height);
        //context.drawImage(bg_paris, 0, 0, 800, 600);

        // Timer text
        var textTime = "TIME : ";
        if(Math.floor(timer) > 10 &amp;&amp; Math.floor(timer) &lt; 100) {
            textTime += "0";
        } else {
            if(Math.floor(timer) &lt; 10) {
                textTime += "00";
            }
        }
        textTime += Math.floor(timer);
        context.fillStyle = "white";
        context.strokeStyle = "black";
        context.lineWidth = 1.6;
        context.font = "bolder 30px Arial";
        context.fillText(textTime, 700 - 65, 40);
        context.strokeText(textTime, 700 - 65, 40);

        // Score text
        var textScore = "SCORE : " + player.score;
        context.lineWidth = 1.3;
        context.font = "bolder 23px Arial";
        context.fillText(textScore, 20, 30);
        context.strokeText(textScore, 20, 30);

        // Lives text
        var textLives = "LIVES : ";
        if(player.livesNumber > 0) {
            for(var i=0; i&lt;player.livesNumber; i++) {
                textLives += "I";
            }
        } else {
            textLives += "0";
        }
        context.fillText(textLives, 20, 57);
        context.strokeText(textLives, 20, 57);

        // platforms drawing
        for (var i=0; i &lt; platforms.length; i++) {
            if(platforms[i].exist){
                if(platforms[i].isDestructible){
                    context.fillStyle = DESTRUCTIBLE_PLATFORM_COLOR;
                } else {
                    context.fillStyle = PLATFORM_COLOR ;
                }

                context.fillRect(platforms[i].position.x, platforms[i].position.y, platforms[i].width, platforms [i].height);
            }
        }

        // ladders drawing
        context.fillStyle= LADDER_COLOR ;
        for (var i=0; i &lt; ladders.length; i++) {
            context.fillRect(ladders[i].position.x, ladders[i].position.y, ladders[i].width, ladders[i].height);
        }

        // balloons displaying
        for(var i=0 ; i&lt;balloons.length ;i++){
            if(balloons[i].size.number > 0){
                fillCircle(balloons[i]);
            }
        }
        // weapons drawing
        for(var i=0 ; i &lt; weapons.length ; i++){
            var weaponWidth = 0, weaponColor;
            switch(weapons[i].type){
                case GRAPPLE_HOOK_NUMBER :
                case DOUBLE_HOOK_NUMBER:
                    weaponColor = GRAPPLE_HOOK_COLOR;
                    weaponWidth = HOOK_WITDH;
                    break;

                case TRIDENT_NUMBER :
                    if(weapons[i].time &lt; 1){
                        weaponColor = TRIDENT_COLOR1 ;
                    } else if(weapons[i].time &lt; 2){
                        weaponColor = TRIDENT_COLOR2 ;
                    } else {
                        weaponColor = TRIDENT_COLOR3 ;
                    }
                    weaponWidth = HOOK_WITDH;
                    break;
            }
            context.fillStyle = weaponColor;
            context.fillRect(weapons[i].position.x,weapons[i].position.y,weaponWidth,-weapons[i].length);
        }

        // Drawing of the player
        context.fillStyle = player.color;
        context.fillRect(player.position.x, player.position.y, player.width, player.height);

        // Victory and defeat screen
        if(player.livesNumber > 1){
            if(victory){
                context.fillStyle = "green";
                context.fillRect(context.width/5,context.height/5,context.width/5*3,context.height/5*3);
                context.fillStyle = "black";
                context.font = '48px serif';
                context.textAlign = "center";
                context.fillText("Et c'est gagné !", cvs.width/2, cvs.height/2);
            } else {
                if(defeat) {
                    player.livesNumber -= 1;
                    defeat = false;
                    levelInitialization(numLevel);    
                }
            }
        } else{
            if(victory){
                context.fillStyle = "green";
                context.fillRect(context.width/5,context.height/5,context.width/5*3,context.height/5*3);
                context.fillStyle = "black";
                context.font = '48px serif';
                context.textAlign = "center";
                context.fillText("Et c'est gagné !", cvs.width/2, cvs.height/2);
            } else {
                if(defeat) {
                    player.livesNumber -= 1;
                    context.fillStyle = "red";
                    context.fillRect(cvs.width/5,cvs.height/5,cvs.width/5*3,cvs.height/5*3);
                    context.fillStyle = "black";
                    context.font = '48px serif';                
                    context.textAlign = "center";
                    context.fillText("Et c'est perdu... ", cvs.width/2, cvs.height/2);
                }
            }
        }
    }
}

/**
*  Key down event
*/
captureKeyboardPress = function(event) {
    if(numLevel == 0) { // menu
        switch(event.keyCode) {
            case 13:
                numLevel = 1;
                break;
            case 49: // niveau 1
            case 50: // niveau 2
            case 51: // niveau 3
            case 52: // niveau 4
                numLevel = event.keyCode - 48;
                levelInitialization(numLevel);
                break;
        }
    } else { // jeu
        switch (event.keyCode) {
            // Player1 left or right
            case 39:
            case 37:
                playerMove(event.keyCode);
                break;

            // Player1 up or down
            case 38:
            case 40:
                playerMoveLadder(event.keyCode);
                break;

            // 'P' means pause or unpause
            case 80:
                pause = !pause;
                break;

            // Space for fire the weapon
            case 32:
                shootWeapon(player);
                break;

            // Enter to insert credits and play again
            case 13:
                defeat = false;
                pause = false;
                levelInitialization(numLevel);
                player.livesNumber = 3;
                player.score = 0;
                break;

            // Shortcut to victory                                                                      // BETA FUNCTION
            case 71:
                victory = !victory;
                break;

            // Shortcut to defeat                                                                       // BETA FUNCTION
            case 72:
                defeat = !defeat;
                break;

            //Activate the default weapon : the grapple hook                                            // BETA FUNCTION
            case 82:
                player.powerOn = GRAPPLE_HOOK_NUMBER ;
                console.log("Grappin activé");
                break;

            //Activate the powerOn double grapple hook                                                  // BETA FUNCTION
            case 84: 
                player.powerOn = DOUBLE_HOOK_NUMBER ;
                console.log("Double grappin activé");
                break;

            //Activate the powerOn Trident                                                              // BETA FUNCTION
            case 89:
                player.powerOn = TRIDENT_NUMBER ;
                console.log("Trident activé");
                break;

            //Make the player invincible                                                                // BETA FUNCTION
            case 73:
                if(isInvincible){
                    console.log("Joueur plus invincible");
                } else {
                console.log("Joueur invincible");
                }
                isInvincible = !isInvincible;
                
            break;        
        }
    }
}

/**
*  Key up event
*/
captureKeyboardReleased = function(event) {
    switch (event.keyCode) {
        //Player1 left or right
        case 39:
        case 37:
            playerStopMove(event.keyCode);
            break;
        case 38:
        case 40:
            playerStopMoveLadder();
            break;
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#BALLOON_SIZE">BALLOON_SIZE</a></li><li><a href="global.html#BALLOON_SPEED">BALLOON_SPEED</a></li><li><a href="global.html#balloons">balloons</a></li><li><a href="global.html#BALLOONS_LIST">BALLOONS_LIST</a></li><li><a href="global.html#captureKeyboardPress">captureKeyboardPress</a></li><li><a href="global.html#captureKeyboardReleased">captureKeyboardReleased</a></li><li><a href="global.html#collisionsAngles">collisionsAngles</a></li><li><a href="global.html#collisionsWithPlayer">collisionsWithPlayer</a></li><li><a href="global.html#context">context</a></li><li><a href="global.html#deleteDoubleHook">deleteDoubleHook</a></li><li><a href="global.html#deleteWeapon">deleteWeapon</a></li><li><a href="global.html#DESTRUCTIBLE_PLATFORM_COLOR">DESTRUCTIBLE_PLATFORM_COLOR</a></li><li><a href="global.html#detectPlatform">detectPlatform</a></li><li><a href="global.html#fillCircle">fillCircle</a></li><li><a href="global.html#findLadder">findLadder</a></li><li><a href="global.html#gameLoop">gameLoop</a></li><li><a href="global.html#GRAPPLE_HOOK_NUMBER">GRAPPLE_HOOK_NUMBER</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#isBalloonBetweenRectangleX">isBalloonBetweenRectangleX</a></li><li><a href="global.html#isBalloonBetweenRectangleY">isBalloonBetweenRectangleY</a></li><li><a href="global.html#isBalloonCollidingBottomLeftCorner">isBalloonCollidingBottomLeftCorner</a></li><li><a href="global.html#isBalloonCollidingBottomRightCorner">isBalloonCollidingBottomRightCorner</a></li><li><a href="global.html#isBalloonCollidingTopLeftCorner">isBalloonCollidingTopLeftCorner</a></li><li><a href="global.html#isBalloonCollidingTopRightCorner">isBalloonCollidingTopRightCorner</a></li><li><a href="global.html#isBalloonNearObject">isBalloonNearObject</a></li><li><a href="global.html#isDefeat">isDefeat</a></li><li><a href="global.html#isInHorizontalCollision">isInHorizontalCollision</a></li><li><a href="global.html#isInVerticalCollision">isInVerticalCollision</a></li><li><a href="global.html#isNotOnPlatformOrGround">isNotOnPlatformOrGround</a></li><li><a href="global.html#isOnFocus">isOnFocus</a></li><li><a href="global.html#isPlayerWithinObject">isPlayerWithinObject</a></li><li><a href="global.html#isVictory">isVictory</a></li><li><a href="global.html#isWeaponBetweenX">isWeaponBetweenX</a></li><li><a href="global.html#keepBalloonOutsideObjects">keepBalloonOutsideObjects</a></li><li><a href="global.html#keepBalloonWithinBorders">keepBalloonWithinBorders</a></li><li><a href="global.html#keepPlayerWithinBorder">keepPlayerWithinBorder</a></li><li><a href="global.html#LADDER_WIDTH">LADDER_WIDTH</a></li><li><a href="global.html#ladders">ladders</a></li><li><a href="global.html#lastUpdate">lastUpdate</a></li><li><a href="global.html#levelInitialization">levelInitialization</a></li><li><a href="global.html#numLevel">numLevel</a></li><li><a href="global.html#outputSpeed">outputSpeed</a></li><li><a href="global.html#platforms">platforms</a></li><li><a href="global.html#PLATFORMS_LIST">PLATFORMS_LIST</a></li><li><a href="global.html#player">player</a></li><li><a href="global.html#playerMove">playerMove</a></li><li><a href="global.html#playerMoveLadder">playerMoveLadder</a></li><li><a href="global.html#playerStopMove">playerStopMove</a></li><li><a href="global.html#playerStopMoveLadder">playerStopMoveLadder</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#shootGrappleHook">shootGrappleHook</a></li><li><a href="global.html#shootWeapon">shootWeapon</a></li><li><a href="global.html#squareDistanceBetweenPoints">squareDistanceBetweenPoints</a></li><li><a href="global.html#stopHooks">stopHooks</a></li><li><a href="global.html#timer">timer</a></li><li><a href="global.html#update">update</a></li><li><a href="global.html#updateCircleColor">updateCircleColor</a></li><li><a href="global.html#weapons">weapons</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Apr 02 2019 23:05:56 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
