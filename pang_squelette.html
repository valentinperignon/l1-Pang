<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Pang</title>
    <script>

    // ------------------------------
    //  Variables
    // ------------------------------

    // Context
    var context = null;


    // An array of all the balloons in the game
    // With the position, the radius, the velocity and the gravity for this balloon. Plus his color because it is beautiful.
    var balloons = [
        {center: {x: 400, y:30},
        radius:30,
        velocity:{ x: .8, y: 0},
        gravity: {x :0, y: 9.81/1000},
        }
    ];

    //Balloons related variables
    const BALLOON_SPEED = 0.1;

    // when did we update the game last time ?
    var lastUpdate = Date.now();

    // All the platforms
    var platformsList = {
        level1 : [
            {
                "position":{
                    "x": 575,
                    "y": 200
                },
                "width": 120,
                "height": 400,
                "exist": true,
                "isDestructible": false
            },
            {
                "position":{
                    "x": 460,
                    "y": 200
                },
                "width": 80,
                "height": 40,
                "exist": true,
                "isDestructible": false
            },
            {
                "position":{
                    "x": 275,
                    "y": 200
                },
                "width": 80,
                "height": 40,
                "exist": true,
                "isDestructible": false
            },
            {
                "position":{
                    "x": 125,
                    "y": 400
                },
                "width": 80,
                "height": 40,
                "exist": true,
                "isDestructible": true
            }
        ],
    }
    var platforms = platformsList.level1;

    
    // ### GRAPHICS VARIABLES ###
    // Colors
    const DESTRUCTIBLE_PLATFORM_COLOR = "darkgrey";
    const PLATFORM_COLOR = "black";
    const LADDER_COLOR = "gray";
    const BALLOON_COLOR = "red";
    const GRAPPLE_HOOK_COLOR = "red";
    const TRIDENT_COLOR = "orange"

    // ------------------------------
    //  Functions
    // ------------------------------

    /**
     * It does exactly what you expect
     */
    function keepBalloonWithinBorders(ball){
        var changement = false;
        //Top
        if(ball.center.y < ball.radius){
            ball.center.y = ball.radius;
            ball.velocity.y = -ball.velocity.y;
            changement = true;
        } else {
            //Bottom
            if(ball.center.y > cvs.height - ball.radius){
                ball.center.y = cvs.height - ball.radius;
                ball.velocity.y = -ball.velocity.y;
                changement = true;
            }
        }
        //Left
        if(ball.center.x < ball.radius){
            ball.center.x = ball.radius;
            ball.velocity.x = -ball.velocity.x;
            changement = true;
        } else {
            //Right
            if(ball.center.x > cvs.width-ball.radius){
                ball.center.x = cvs.width - ball.radius;
                ball.velocity.x = -ball.velocity.x;
                changement = true;
            }
        }
        return(changement);
    }


    /**
     * Like FillRect, but for circles
     */
    function fillCircle(circle){
        var canvas = document.getElementById("cvs");
        var context = canvas.getContext("2d");
        context.beginPath();
        context.fillStyle=BALLOON_COLOR;
        context.arc(circle.center.x, circle.center.y, circle.radius, 0, 2 * Math.PI);
        context.fill();
    }


    /**
    * Return (the distance between two points)²
    * @param pointA with x and y
    * @param pointB with x and y
    */
    function squareDistanceBetweenPoints(pointA,pointB){
        return((pointA.x - pointB.x)*(pointA.x - pointB.x) + (pointA.y - pointB.y)*(pointA.y - pointB.y));
    }

    /**
    * Is the balloonX between the x and (x + width) of the rectangle ? Return boolean
    * Inputs : balloon with x, rectangle with x and width
    */
    function isBalloonBetweenRectangleX(ball,rectangle){
        return(ball.center.x > rectangle.position.x && ball.center.x < rectangle.position.x + rectangle.width);
    }

    /**
    * Is the ballon Y between the y and (y + width) of the rectangle ? Return boolean
    * Inputs : balloon with y, rectangle with y and height
    */
    function isBalloonBetweenRectangleY(ball,rectangle){
        return(ball.center.y >= rectangle.position.y && ball.center.y <= rectangle.position.y + rectangle.height);
    }

    /**
    * Is the balloon near a plateform ? (= near to collide but we don't know if it does)
    * @return true or false
    */
    function isBalloonNearObject(ball,object){
        return(!(ball.center.x < object.position.x - ball.radius
        || ball.center.x > object.position.x + object.width + ball.radius
        || ball.center.y < object.position.y - ball.radius
        || ball.center.y > object.position.y + object.height + ball.radius))
    }

    /**
    * @return 'true' if the balloon touches the bottom or the upside of a rectangular object
    */
    function isInHorizontalCollision(ball, object){
        var collision = false;
        if(isBalloonBetweenRectangleX(ball, object)){
            if(ball.center.y >= object.position.y - ball.radius 
            && ball.center.y <= object.position.y + object.height + ball.radius){
                collision = true;
            }
        }
        return(collision);
    }

    /**
    *@return 'true' if the balloon touches the left or the right of a rectangular object
    */
    function isInVerticalCollision(ball, object){
        var collision = false;
        if(isBalloonBetweenRectangleY(ball, object)){
            if(ball.center.x >= object.position.x - ball.radius
            && ball.center.x <= object.position.x + object.width + ball.radius){
                collision = true;
            }
        }
        return(collision);
    }


    
    /**
    * Is the balloon colliding with the bottom right corner ?
    * @return true is yes, else false
    */
    function isBalloonCollidingBottomRightCorner(ball,object){
        let bottomRightCorner = {x: object.position.x + object.width, y: object.position.y + object.height} ;
        return(squareDistanceBetweenPoints(ball.center,bottomRightCorner) <= ball.radius * ball.radius);
    }

    /**
    * Is the balloon colliding with the top right corner ?
    * @return true is yes, else false
    */
    function isBalloonCollidingTopRightCorner(ball,object){
        let topRightCorner = {x: object.position.x + object.width, y: object.position.y} ;
        return(squareDistanceBetweenPoints(ball.center,topRightCorner) <= ball.radius * ball.radius);
    }

    /**
    * Is the balloon colliding with the top left corner ?
    * @return true is yes, else false
    */
    function isBalloonCollidingTopLeftCorner(ball,object){
        let topLeftCorner = {x: object.position.x, y: object.position.y} ;
        return(squareDistanceBetweenPoints(ball.center,topLeftCorner) <= ball.radius * ball.radius);
    }


    /**
    * Is the balloon colliding with the top right corner ?
    * @return true is yes, else false
    */
    function isBalloonCollidingBottomLeftCorner(ball,object){
        let bottomLeftCorner = {x: object.position.x, y: object.position.y + object.height} ;
        return(squareDistanceBetweenPoints(ball.center,bottomLeftCorner) <= ball.radius * ball.radius);
    }

 


    /**
     * Make sure the balloons are not colliding with rectangle objects like platforms
     */
    function keepBallonOutsideObjects(ball, object){
        if(object.exist){
            
            // Is the balloon near the object ? Simple and quick verification (optimize)
            if(isBalloonNearObject(ball,object)){
                
                // Collision with horizontal surfaces
                if(isInHorizontalCollision(ball,object)){
                    ball.velocity.y *= -1;
                // or collision with vertical surfaces
                } else if(isInVerticalCollision(ball,object)){
                    ball.velocity.x *= -1;
                // or in collision with angles
                } else {
                    
                    //Top left corner
                    if(isBalloonCollidingTopLeftCorner(ball,object)){
                        // Equation of the angle straith line (@return y)
                        function equation(x){
                            return(-(x-object.position.x) + object.position.y);
                        }

                        // The balloon is in the vertical area
                        if(ball.center.y > equation(ball.center.x)){
                            ball.velocity.x *= -1;

                        // The balloon is in the horizontal area
                        } else {
                            ball.velocity.y *= -1;
                        }


                    //Top right corner
                    } else if(isBalloonCollidingTopRightCorner(ball,object)){
                        // Equation of the angle straith line (@return y)
                        function equation(x){
                            return((x-object.position.x-object.width) + object.position.y);
                        }

                        // The balloon is in the vertical area
                        if(ball.center.y > equation(ball.center.x)){
                            ball.velocity.x *= -1;

                        // The balloon is in the horizontal area
                        } else {
                            ball.velocity.y *= -1;
                        }

                    // Bottom left corner
                    } else if(isBalloonCollidingBottomLeftCorner(ball,object)){
                        // Equation of the angle straith line (@return y)
                        function equation(x){
                            return((x-object.position.x) + object.position.y + object.height);
                        }

                        // The balloon is in the vertical area
                        if(ball.center.y < equation(ball.center.x)){
                            ball.velocity.x *= -1;

                        // The balloon is in the horizontal area
                        } else {
                            ball.velocity.y *= -1;
                        }
                    // Bottom right corner
                    } else if(isBalloonCollidingBottomRightCorner(ball,object)){
                        // Equation of the angle straith line (@return y)
                        function equation(x){
                            return((x - object.position.x - object.width ) + object.position.y + object.height);
                        }

                        // The balloon is in the vertical area
                        if(ball.center.y < equation(ball.center.x)){
                            ball.velocity.x *= -1;

                        // The balloon is in the horizontal area
                        } else {
                            ball.velocity.y *= -1;
                        }
                    }




                }
                




            }
        }
    }
    
    /**
    *
    */
    function outputSpeed(ball){
        var speed = Math.sqrt(Math.pow(ball.velocity.x, 2) + Math.pow(ball.velocity.y, 2));
        console.log(speed);
    }
    

    // ------------------------------
    //  Game
    // ------------------------------

    /**
    * Initialization of the game
    */
    init = function() {
       // Initizalisation of the global var context
        context = document.getElementById("cvs").getContext("2d");
        context.width = document.getElementById("cvs").width;
        context.height = document.getElementById("cvs").height;

        // Go my little game loop, and never stop
        gameLoop();
    }

    /**
    * Game loop
    */
    gameLoop = function() {
        var delta = Date.now()-lastUpdate;
        lastUpdate = Date.now();

        // update of the game's state
        update(delta);
        
        // draw the game
        render();
    
        requestAnimationFrame(gameLoop);
    }

    /**
    *  Game update
    *  @param delta the time between now and the last update
    */
    update = function(delta) {
        // Update balloons position 
        for(var i=0 ; i<balloons.length ; i++){
            if(balloons[i].radius>0){
                // Update balloons[i].velocity
                balloons[i].velocity.x += balloons[i].gravity.x*delta;
                balloons[i].velocity.y += balloons[i].gravity.y*delta;

                // Update balloons[i].center
                balloons[i].center.x += balloons[i].velocity.x * delta * BALLOON_SPEED;
                balloons[i].center.y += balloons[i].velocity.y * delta * BALLOON_SPEED;
            }
        }

       // outputSpeed(balloons[0]);

        //Verifying that balloons do not crash into something
        for(var i=0 ; i < balloons.length ; i++){

            if(balloons[i].radius>0){    

                //No, you will not stick out
                var bordersCorrection = keepBalloonWithinBorders(balloons[i]);

                if(!bordersCorrection){
                
                    //Don't go into platforms !
                    for(var j = 0 ; j < platforms.length ; j++){
                        keepBallonOutsideObjects(balloons[i], platforms[j]);
                    }
                }
      
            }
        }



          }

    /**
    *  Game render
    */
    render = function() {
        // Wiping the screen
        context.clearRect(0, 0, context.width, context.height);

		// platforms drawing
        for (var i=0; i < platforms.length; i++) {
        	if(platforms[i].exist){
                if(platforms[i].isDestructible){
                    context.fillStyle = DESTRUCTIBLE_PLATFORM_COLOR;
                } else {
                    context.fillStyle = PLATFORM_COLOR ;
                }

                context.fillRect(platforms[i].position.x, platforms[i].position.y, platforms[i].width, platforms [i].height);
            }
        }

      
        // balloons displaying
        for(var i=0 ; i<balloons.length ;i++){
            if(balloons[i].radius>0){
                fillCircle(balloons[i]);
            }
        }

      
    }


    </script>
</head>
<body onload="init()">

    <canvas id="cvs" width="800" height="600" style="margin: 10px auto; border: solid 1px #000;"></canvas>

    <p> Commandes : 
        <ul>
            <li>R : Arme par défaut</li>
            <li>T : Trident </li>
            <li>G : victoire immédiate</li>
            <li>P : pause</li>
        </ul>
    </p>
</body>
</html>
